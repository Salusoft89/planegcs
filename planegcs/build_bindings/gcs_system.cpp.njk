#include <iostream>
#include <vector>
#include "GCS.h"

using namespace GCS;
using namespace std;

class GcsSystem : System
{
    public:
        vector<double *> params;
        vector<bool> is_fixed;
        DebugMode debug_mode;

        GcsSystem() : System() {
            params = vector<double *>();
            is_fixed = vector<bool>();
            debug_mode = DebugMode::NoDebug;
        }

        int params_size()
        {
            return params.size();
        }

        double get_param(int i)
        {
            return *params[i];
        }

        void set_param(int i, double value, bool fixed)
        {
            *params[i] = value;
            is_fixed[i] = fixed;
        }

        int push_param(double value, bool fixed)
        {
            int index = params.size();
            params.push_back(new double(value));
            is_fixed.push_back(fixed);
            return index;
        }

        bool get_is_fixed(int i)
        {
            return is_fixed[i];
        }

        int solve_system()
        {
            vector<double *> solved_params;
            for (int i = 0; i < params.size(); ++i)
            {
                if (!is_fixed[i])
                {
                    solved_params.push_back(params[i]);
                }
            }
            return solve(solved_params);
        }

        vector<double> get_params()
        {
            vector<double> p;
            for (int i = 0; i < params.size(); ++i)
            {
                p.push_back(*params[i]);
            }
            return p;
        }

        vector<int> get_conflicting()
        {
            vector<int> conflicting;
            getConflicting(conflicting);
            return conflicting;
        }

        void clear()
        {
            for (int i = 0; i < params.size(); ++i)
            {
                delete params[i];
            }
            params.clear();
            is_fixed.clear();
            clear();
        }

        void apply_solution()
        {
            applySolution();
        }

        int dof()
        {
            return dofsNumber();
        }

        bool has_conflicting()
        {
            return hasConflicting();
        }

        bool has_redundant()
        {
            return hasRedundant();
        }

        void clear_by_id(int id)
        {
            clearByTag(id);
        }

        void set_debug_mode(DebugMode debug_mode)
        {
            this->debug_mode = debug_mode;
        }

        // make objects from params
        Point make_point(int px_i, int py_i)
        {
            Point p;
            p.x = params[px_i];
            p.y = params[py_i];
            return p;
        }

        Line make_line(int p1x_i, int p1y_i, int p2x_i, int p2y_i)
        {
            Point p1 = make_point(p1x_i, p1y_i);
            Point p2 = make_point(p2x_i, p2y_i);

            Line l;
            l.p1 = p1;
            l.p2 = p2;

            return l;
        }

        Circle make_circle(int cx_i, int cy_i, int rad_i)
        {
            Point cp = make_point(cx_i, cy_i);

            Circle c;
            c.center = cp;
            c.rad = params[rad_i];

            return c;
        }

        Ellipse make_ellipse(
            int cx_i, int cy_i, int focus1x_i, int focus1y_i, int radmin_i
        )
        {
            Ellipse e;
            e.center = make_point(cx_i, cy_i);
            e.focus1 = make_point(focus1x_i, focus1y_i);
            e.radmin = params[radmin_i];

            return e;
        }

        Hyperbola make_hyperbola(
            int cx_i, int cy_i, int focus1x_i, int focus1y_i, int radmin_i
        )
        {
            Hyperbola h;
            h.center = make_point(cx_i, cy_i);
            h.focus1 = make_point(focus1x_i, focus1y_i);
            h.radmin = params[radmin_i];

            return h;
        }

        Parabola make_parabola(
            int vertexx_i, int vertexy_i, int focus1x_i, int focus1y_i
        ) 
        {
            Parabola p;
            p.focus1 = make_point(focus1x_i, focus1y_i);
            p.vertex = make_point(vertexx_i, vertexy_i);

            return p;
        }

        Arc make_arc(
            int cx_i, int cy_i, int startx_i, int starty_i, int endx_i, int endy_i,
            int startangle_i, int endangle_i, int rad_i)
        {
            Point c = make_point(cx_i, cy_i);
            Point start = make_point(startx_i, starty_i);
            Point end = make_point(endx_i, endy_i);

            Arc a;
            a.center = c;
            a.start = start;
            a.startAngle = params[startangle_i];
            a.endAngle = params[endangle_i];
            a.end = end;
            a.rad = params[rad_i];

            return a;
        }

        ArcOfEllipse make_arc_of_ellipse(
            int cx_i, int cy_i, int focus1x_i, int focus1y_i,
            int startx_i, int starty_i, int endx_i, int endy_i,
            int startangle_i, int endangle_i, int radmin_i
        )
        {
            ArcOfEllipse a;
            a.center = make_point(cx_i, cy_i);
            a.start = make_point(startx_i, starty_i);
            a.startAngle = params[startangle_i];
            a.end = make_point(endx_i, endy_i); 
            a.endAngle = params[endangle_i];
            a.radmin = params[radmin_i];
            a.focus1 = make_point(focus1x_i, focus1y_i);

            return a;   
        }

        ArcOfParabola make_arc_of_parabola(
            int startx_i, int starty_i, int endx_i, int endy_i,
            int startangle_i, int endangle_i, int focusx_i, int focusy_i, int vertexx_i, int vertexy_i
        )
        {
            ArcOfParabola a;
            a.start = make_point(startx_i, starty_i);
            a.startAngle = params[startangle_i];
            a.end = make_point(endx_i, endy_i);
            a.endAngle = params[endangle_i];
            a.focus1 = make_point(focusx_i, focusy_i);
            a.vertex = make_point(vertexx_i, vertexy_i);

            return a;
        }

        ArcOfHyperbola make_arc_of_hyperbola(
            int cx_i, int cy_i, int startx_i, int starty_i, int endx_i, int endy_i,
            int startangle_i, int endangle_i, int radmin_i, int focus1x_i, int focus1y_i
        )
        {
            ArcOfHyperbola a;
            a.center = make_point(cx_i, cy_i);
            a.start = make_point(startx_i, starty_i);
            a.startAngle = params[startangle_i];
            a.end = make_point(endx_i, endy_i); 
            a.endAngle = params[endangle_i];
            a.radmin = params[radmin_i];
            a.focus1 = make_point(focus1x_i, focus1y_i);

            return a;   
        }{% include "constraints.cpp.njk" %}

        {# todo: make_bspline #}
};

#include <emscripten/bind.h>  

EMSCRIPTEN_BINDINGS(module) {
    emscripten::register_vector<double>("DoubleVector");
    emscripten::register_vector<int>("IntVector");
    {# Geo.h classes #}
    emscripten::class_<Point>("Point");
    emscripten::class_<Curve>("Curve");
    emscripten::class_<Line, emscripten::base<Curve>>("Line");
    emscripten::class_<Circle, emscripten::base<Curve>>("Circle");
    emscripten::class_<Arc, emscripten::base<Circle>>("Arc");
    emscripten::class_<Ellipse, emscripten::base<Curve>>("Ellipse");
    emscripten::class_<ArcOfEllipse, emscripten::base<Ellipse>>("ArcOfEllipse");
    emscripten::class_<Hyperbola, emscripten::base<Curve>>("Hyperbola");
    emscripten::class_<ArcOfHyperbola, emscripten::base<Hyperbola>>("ArcOfHyperbola");
    emscripten::class_<Parabola, emscripten::base<Curve>>("Parabola");
    emscripten::class_<ArcOfParabola, emscripten::base<Parabola>>("ArcOfParabola");
    emscripten::class_<BSpline, emscripten::base<Curve>>("BSpline");

    {# todo: enums (InternalAlignmentType) #}

    emscripten::class_<GcsSystem>("GcsSystem")
        .constructor<>()
        .function("params_size", &GcsSystem::params_size)
        .function("get_param", &GcsSystem::get_param)
        .function("get_params", &GcsSystem::get_params)
        .function("set_param", &GcsSystem::set_param)
        .function("push_param", &GcsSystem::push_param)
        .function("get_is_fixed", &GcsSystem::get_is_fixed)
        .function("solve_system", &GcsSystem::solve_system)
        .function("get_conflicting", &GcsSystem::get_conflicting)
        .function("clear", &GcsSystem::clear)
        // functions derived from GCS::System
        .function("apply_solution", &GcsSystem::apply_solution)
        .function("dof", &GcsSystem::dof)
        .function("has_conflicting", &GcsSystem::has_conflicting)
        .function("has_redundant", &GcsSystem::has_redundant)
        .function("clear_by_id", &GcsSystem::clear_by_id)
        {# todo: generate make_<geometry> functions #}
        .function("make_line", &GcsSystem::make_line)
        .function("make_point", &GcsSystem::make_point)
        .function("make_circle", &GcsSystem::make_circle)
        .function("make_arc", &GcsSystem::make_arc)
        .function("make_ellipse", &GcsSystem::make_ellipse)
        .function("make_arc_of_ellipse", &GcsSystem::make_arc_of_ellipse)
        .function("make_hyperbola", &GcsSystem::make_hyperbola)
        .function("make_arc_of_hyperbola", &GcsSystem::make_arc_of_hyperbola)
        .function("make_parabola", &GcsSystem::make_parabola)
        .function("make_arc_of_parabola", &GcsSystem::make_arc_of_parabola)
        // constraint functions
        {% include "constraints_emscripten.cpp.njk" %}
        ;
}